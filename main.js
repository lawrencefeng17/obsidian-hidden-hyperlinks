/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HiddenHyperlinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  // Default values for future settings
};
var HiddenHyperlinksPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerMarkdownPostProcessor((element, context) => {
      this.processHiddenHyperlinks(element, context);
    });
    this.addStyle();
  }
  onunload() {
    this.removeStyle();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  processHiddenHyperlinks(element, context) {
    const regex = /\{([^|]+)\|hidden:([^}]+)\}/g;
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      null
    );
    const textNodes = [];
    let node;
    while (node = walker.nextNode()) {
      textNodes.push(node);
    }
    textNodes.forEach((textNode) => {
      const text = textNode.textContent || "";
      if (text.includes("{") && text.includes("hidden:")) {
        console.log("Hidden Hyperlinks: Found potential match in text:", text);
      }
      if (regex.test(text)) {
        console.log("Hidden Hyperlinks: Processing text:", text);
        this.replaceHiddenHyperlinks(textNode, text);
      }
    });
  }
  replaceHiddenHyperlinks(textNode, text) {
    const regex = /\{([^|]+)\|hidden:([^}]+)\}/g;
    const parent = textNode.parentNode;
    if (!parent)
      return;
    let lastIndex = 0;
    let match;
    const fragment = document.createDocumentFragment();
    while ((match = regex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
      }
      const hiddenLink = this.createHiddenHyperlinkElement(match[1], match[2]);
      fragment.appendChild(hiddenLink);
      lastIndex = regex.lastIndex;
    }
    if (lastIndex < text.length) {
      fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
    }
    parent.replaceChild(fragment, textNode);
  }
  createHiddenHyperlinkElement(visibleText, hiddenText) {
    const span = document.createElement("span");
    span.className = "hidden-hyperlink";
    span.textContent = visibleText;
    span.title = "Click to copy hidden text to clipboard";
    span.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      try {
        await navigator.clipboard.writeText(hiddenText);
        this.showCopyFeedback(span, "Copied!");
      } catch (err) {
        console.error("Failed to copy to clipboard:", err);
        this.showCopyFeedback(span, "Copy failed");
      }
    });
    return span;
  }
  showCopyFeedback(element, message) {
    const originalText = element.textContent;
    element.textContent = message;
    element.style.opacity = "0.7";
    setTimeout(() => {
      element.textContent = originalText;
      element.style.opacity = "1";
    }, 1e3);
  }
  addStyle() {
    const styleEl = document.createElement("style");
    styleEl.id = "hidden-hyperlinks-style";
    styleEl.textContent = `
			.hidden-hyperlink {
				color: var(--link-color, #7c3aed);
				text-decoration: underline;
				text-decoration-style: dashed;
				cursor: pointer;
				border-radius: 3px;
				padding: 1px 2px;
				transition: all 0.2s ease;
			}
			
			.hidden-hyperlink:hover {
				background-color: var(--link-color-hover, rgba(124, 58, 237, 0.1));
				text-decoration-style: solid;
			}
			
			.hidden-hyperlink:active {
				background-color: var(--link-color-hover, rgba(124, 58, 237, 0.2));
				transform: scale(0.98);
			}
		`;
    document.head.appendChild(styleEl);
  }
  removeStyle() {
    const styleEl = document.getElementById("hidden-hyperlinks-style");
    if (styleEl) {
      styleEl.remove();
    }
  }
};
